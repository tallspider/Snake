#include <stdlib.h>
#include <stdbool.h>


volatile int pixel_buffer_start; // global variable
void clear_screen();
void plot_pixel(int x, int y, short int line_color);
void draw_line(int x0, int x1, int y0, int y1, short int colour);
void wait_for_vsync();
void draw();
void draw_box(int x, int y, short int colour);
void swap(int * one, int * two);
int colour_box[8], dx_box[8], dy_box[8], x_box[8], y_box[8];
short int colour[10] = {0xFFFF, 0xF800, 0xD29C, 0x07E0, 0x001F, 0xFFA0, 0x91A3, 0x57BCDE, 0xFFFC, 0xD631};


int main(void) {
    volatile int * pixel_ctrl_ptr = (int *)0xFF203020;

    // declare other variables(not shown)
    // initialize location and direction of rectangles(not shown)

    /* set front pixel buffer to start of FPGA On-chip memory */
    *(pixel_ctrl_ptr + 1) = 0xC8000000; // first store the address in the 
                                        // back buffer
    /* now, swap the front/back buffers, to set the front buffer location */
    wait_for_vsync();
    /* initialize a pointer to the pixel buffer, used by drawing functions */
    pixel_buffer_start = *pixel_ctrl_ptr;
    clear_screen(); // pixel_buffer_start points to the pixel buffer
    /* set back pixel buffer to start of SDRAM memory */
    *(pixel_ctrl_ptr + 1) = 0xC0000000;
    pixel_buffer_start = *(pixel_ctrl_ptr + 1); // we draw on the back buffer

    for (int i = 0; i < 8; i++) {
	dx_box[i] = (rand() % 2) * 2 - 1;
	dy_box[i] = (rand() % 2) * 2 - 1;
	colour_box[i] = colour[rand() % 10];
	x_box[i] = rand() % 320; // 0 to 319
	y_box[i] = rand() % 240; // 0 to 239 
    }

    while (1) {
	draw();
        wait_for_vsync(); // swap front and back buffers on VGA vertical sync
        pixel_buffer_start = *(pixel_ctrl_ptr + 1); // new back buffer
    }

    return 0;

}

void plot_pixel(int x, int y, short int line_color)
{
    *(short int *)(pixel_buffer_start + (y << 10) + (x << 1)) = line_color;
}


void draw_line(int x0, int y0, int x1, int y1, short int colour) {
	bool is_steep = (abs(y1 - y0) > abs(x1 - x0));

	if (is_steep) {
		swap(&x0, &y0);
		swap(&x1, &y1);
	}

	if (x0 > x1) {
		swap(&x0, &x1);
		swap(&y0, &y1);
	}


	int dx = x1 - x0;
	int dy = abs(y1 - y0);
	int error = (dx / 2) * (-1);
        int y = y0;
	int y_step = 0;
        if (y0 < y1) y_step = 1;
	    else y_step = -1;

	for (int x = x0; x < (x1+1); x++) {
	    if (is_steep) plot_pixel(y, x, colour);
		else plot_pixel(x, y, colour);

		error += dy;
		if (error >= 0) {
			y = y + y_step;
			error = error - dx;
		}
	}
}

void clear_screen() {
   for (int x = 0; x < 320; x++) { // 319 columns
	   for (int y = 0; y < 240; y++) { // 239 rows
		   plot_pixel(x, y, 0x0); // black is #000000
	   }
   }

}

void wait_for_vsync() {
	volatile int * pixel_ctrl_ptr = (int *)0xFF203020;
	register int status;
	
	*pixel_ctrl_ptr = 1; // start synchronization (write to buffer register)
	status = *(pixel_ctrl_ptr + 3);

	while ((status & 0x01) != 0) { // wait for S to be 0
		status = *(pixel_ctrl_ptr + 3);
	}
}


void swap(int * one, int * two) {
	int temp = *one;
	*one = *two;
	*two = temp;
}

void draw_box(int x, int y, short int colour) {
	for(int i = x - 2; i <= x + 2; i++){
        	for(int j = y - 2; j <= y + 2; j++){
            		plot_pixel(i, j, colour);
        	}
    	}
}

void draw() {
	clear_screen();
  /*
	for (int i = 0; i < 8; i++) {
		draw_box(x_box[i], y_box[i], colour_box[i]);
		draw_line(x_box[i], y_box[i], x_box[(i+1) % 8], y_box[(i+1) % 8], colour_box[i]);
		
		if (x_box[i] <= 2 || x_box[i] >= (319-2) || y_box[i] <= 0 || y_box[i] >= (239-2)) {
			if (x_box[i] <= 2) {
				dx_box[i] = 1;
			} else if (x_box[i] >= (319-2)) {
				dx_box[i] = -1;
			}

			if (y_box[i] <= 2) {
				dy_box[i] = 1;
			} else if (y_box[i] >= (239-2)) {
				dy_box[i] = -1;
			}
		}

			x_box[i] += dx_box[i];
			y_box[i] += dy_box[i];
	}
  */
}







/*
Init snake
Init apple
Draw snake
Draw apple
while(run){
	Save position of snake tail
update snake by defined increments
	Check if snake position is legal
	if(legal){
		Draw background color on tail block
		(also on head block if we want snake to have distinct head)
		Draw new head block
		if(snake head on apple){
			Increase points
			Update snake to be 1 longer
			Init new apple
			Draw new apple
}
wait_for_vsync()
} else {
	Draw Game Over panel
	wait_for_vsync()
	Draw Game Over panel
	Exit loop
}
}
*/
